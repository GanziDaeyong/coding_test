#!/usr/bin/env python
# coding: utf-8

# In[ ]:


"""
2016-19620 언어학과 정대용 / 두 번째 과제. 

아래는 제가 코드를 짜면서 실수했던 점과 완성된 코드에 대한 설명입니다. 시간이 부족하시면 앞에 <포인트> 라고 적어둔 4, 5번만 읽어주셔도 됩니다.


두 번째 문제의 핵심은 x축, y축, z축 내에서의 요소 비교를 얼마나 예외 없이 깔끔히 구현하는 것인가라 생각했습니다. 

1. 
처음에는 A,B,C,D의 값들을 넣은 리스트와, 그를 sorted() 함수를 사용해 오름차순으로 정렬한 리스트를 만들고, 오름차순으로 정렬된 리스트에서 A,B,C,D가 어디에 위치하는지에 따라 +3, +1, -1. -3의 속도를 부여하였습니다. (가장 작은 값부터 가장 큰 값까지 순서대로 +3, +1, -1, -3)

2. 
이 방법은 코드가 깔끔하고 이해가 쉬우며, 매우 빨랐으나, 예제와 비교해보았을 때 오답이 나왔습니다. 곧, 위와 같은 방식은 중복을 처리할 수 없다는 것을 깨달았습니다. 중복을 처리하기 위해 조건문들을 덧붙이다보면, 코드가 매우 무거워질 것이 분명했습니다.

3. 
고민하던 중, 문득 파이썬의 리스트 컴프리헨션 기능을 사용하면 어떨까 라는 생각이 들었습니다. 자연어처리를 공부할 때, 전처리 과정에서 리스트 내 요소들을 가장 효과적으로 처리하는 방법이 리스트 컴프리헨션이었기 때문입니다.

4. <포인트> 
따라서 특정 요소보다 큰 값만을 남기는 리스트의 길이에서 작은 값만을 남기는 리스트의 길이를 빼 주어 해당 요소의 속도를 결정하였습니다.
--------------------------------------------------------------------------------------------------------
len([요소 for 요소 in x_axis if 요소 > x_axis[i]]) - len([요소 for 요소 in x_axis if 요소 < x_axis[i]])
--------------------------------------------------------------------------------------------------------

5. <포인트> 
이러한 방식으로 x축과 y축, z축을 따로 계산하되, 이를 동일한 반복문 내에 작성하여 
--------------------------------------------------------------------------------------------------------
x축의 첫번째 요소 -> y축의 첫번째 요소 -> z축의 첫번째 요소 -> x축의 두번째 요소 -> ... -> 
x축의 네번째 요소 -> y축의 네번째 요소 -> z축의 네번째 요소
--------------------------------------------------------------------------------------------------------
와 같은 순서를 취하도록 했습니다. 그리고 이를 순간_가속도_모음 리스트에 집어넣었습니다. 그럼 자연스레 순간_가속도_모음의 [0:3]은 A좌표, [3:6]은 B좌표, [6:9]는 C좌표, [9:12]는 D좌표가 됩니다. 

6. 
기존 가속도 리스트의 값들과 순간_가속도_모음의 값들을 더해주고, 이렇게 갱신한 기존 가속도와 기존 좌표를 더해주었습니다.

7.
A,B,C,D 좌표와 초기 가속도를 입력하고, 이후 주기 확인을 위해 ch_를 붙인 확인용 버전도 만들어주었습니다. 이후, while문을 이용해 무한루프를 돌리되, 만약 갱신된 좌표값과 초깃값, 갱신된 가속도와 초깃값이 일치한다면 break하도록 했습니다. 여기서 의도적으로 A 좌표와 초깃값을 비교해 같은 경우에만 다른값들의 비교도 실시하도록 했습니다. 처음부터 모든 값들을 비교하면 그만큼 속도가 느려질 수 있기 때문입니다. 

8. 
아울러, 매 스텝마다 무엇인가 출력하면 그만큼 느려지기 때문에 일부러 아무런 출력도 실행하지 않았습니다. 매 스텝마다 좌표값과 가속도롤 츨력하는 경우 약 5분, 매 스텝마다 스텝 번호만 출력하는 경우 정답 출력에 약 3분, 아무것도 출력하지 않는 경우 40초 정도가 소요됩니다.


"""


# In[1]:


#################이는 주피터 노트북에서 편의를 위해 설정한 것입니다. #####################################
#주피터 노트북 환경이 아니라면 주석처리해주십시오.

from IPython.core.display import display, HTML
display(HTML("<style>.container { width: 80% !important; }</style>"))

##########################################################################################################



def 항성계_주기찾기(A,B,C,D,A_vel,B_vel,C_vel,D_vel):

    x_axis = [A[0],B[0],C[0],D[0]]
    y_axis = [A[1],B[1],C[1],D[1]]
    z_axis = [A[2],B[2],C[2],D[2]]
    순간_가속도_모음 = []
    
    for i in range (4):
        x_가속도 =  len([요소 for 요소 in x_axis if 요소 > x_axis[i]]) - len([요소 for 요소 in x_axis if 요소 < x_axis[i]])
        y_가속도 =  len([요소 for 요소 in y_axis if 요소 > y_axis[i]]) - len([요소 for 요소 in y_axis if 요소 < y_axis[i]])
        z_가속도 =  len([요소 for 요소 in z_axis if 요소 > z_axis[i]]) - len([요소 for 요소 in z_axis if 요소 < z_axis[i]])
        순간_가속도_모음.append(x_가속도)
        순간_가속도_모음.append(y_가속도)
        순간_가속도_모음.append(z_가속도)
        #여기서 i 도는 순서에 따라 ABCD로 정렬된다.,
    
    A_vel = [기존가속도+순간가속도 for 기존가속도, 순간가속도 in zip(A_vel,순간_가속도_모음[0:3])]
    B_vel = [기존가속도+순간가속도 for 기존가속도, 순간가속도 in zip(B_vel,순간_가속도_모음[3:6])]
    C_vel = [기존가속도+순간가속도 for 기존가속도, 순간가속도 in zip(C_vel,순간_가속도_모음[6:9])]
    D_vel = [기존가속도+순간가속도 for 기존가속도, 순간가속도 in zip(D_vel,순간_가속도_모음[9:12])]
    A = [기존좌표+가속도 for 기존좌표, 가속도 in zip(A,A_vel)]
    B = [기존좌표+가속도 for 기존좌표, 가속도 in zip(B,B_vel)]
    C = [기존좌표+가속도 for 기존좌표, 가속도 in zip(C,C_vel)]
    D = [기존좌표+가속도 for 기존좌표, 가속도 in zip(D,D_vel)]
            
    return A,B,C,D,A_vel,B_vel,C_vel,D_vel
    
    
    
    
    
A_vel, B_vel, C_vel, D_vel = [0,0,0], [0,0,0], [0,0,0], [0,0,0]
    
A, B, C, D = [1, -11, -8], [8, -7, 0], [11, -7, 10], [-6, -2, 8]
    
ch_A_vel, ch_B_vel, ch_C_vel, ch_D_vel =A_vel, B_vel, C_vel, D_vel
    
ch_A, ch_B, ch_C, ch_D = A, B, C, D
    
i = 1
while True :
    A,B,C,D,A_vel,B_vel,C_vel,D_vel = 항성계_주기찾기(A,B,C,D,A_vel,B_vel,C_vel,D_vel)
    #print("###### %d step #######" %i)
    #print(A,A_vel)
    #print(B,B_vel)
    #print(C,C_vel)
    #print(D,D_vel)
    if A == ch_A :
        if B == ch_B and C == ch_C and D == ch_D and A_vel == ch_A_vel and B_vel == ch_B_vel and C_vel == ch_C_vel and D_vel == ch_D_vel :
            print(A,A_vel)
            print(B,B_vel)
            print(C,C_vel)
            print(D,D_vel)
            print(str(i)+ "가 주기입니다.") 
            break
    i += 1


# In[ ]:




